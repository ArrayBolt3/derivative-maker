#!/bin/bash

## Copyright (C) 2012 - 2022 ENCRYPTED SUPPORT LP <adrelanos@whonix.org>
## See the file COPYING for copying conditions.

set -x
set -e

true "INFO: Currently running script: $BASH_SOURCE $@"

MYDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

cd "$MYDIR"
cd ..
cd help-steps

## TODO
#VMNAME="internalrun"

source pre
source colors
source variables

cd "$MYDIR"
cd ..

check-unicode() {
   ## overwrite with '|| true' because `grep` exits non-zero if no match was found.
   grep_find_unicode_wrapper_output="$(\
      "${dist_developer_meta_files_folder}/usr/bin/dm-check-unicode" \
      --recursive \
      --exclude=control.authcookie \
      "$binary_build_folder_dist" \
      )" \
      || true

   if [ "$grep_find_unicode_wrapper_output" = "" ]; then
      true "INFO: grep_find_unicode_wrapper_output empty, good, OK."
   else
      error "\
   $0: ERROR: Unicode found!

   See also:
   https://forums.whonix.org/t/detecting-malicious-unicode-in-source-code-and-pull-requests/13754
   "
   fi

   true
}

check-source-folder-permissions() {
   ## Debugging.
   true "${bold}${cyan}INFO: PWD: $PWD ${reset}"

   ## Checking if derivative-maker source folder has been obtained (git cloned) as user or root.

   stat_output_owner="$(stat -c %U "$BASH_SOURCE")"
   stat_output_group="$(stat -c %G "$BASH_SOURCE")"

   if [ "$stat_output_owner" = "root" ]; then
      error "${bold}${red}ERROR $BASH_SOURCE: Is owned by root user! Instructions say you should get derivative-maker source code as user, not root! \
Please delete derivative-maker source code folder and get it again as user, not root!${reset}"
   fi

   if [ "$stat_output_group" = "root" ]; then
      error "${bold}${red}ERROR $BASH_SOURCE: Is owned by root group! Instructions say you should get derivative-maker source code as user, not root! \
Please delete derivative-maker source code folder and get it again as user, not root!${reset}"
   fi

   true
}

check-stray-loop-devices() {
   true "INFO: Checking for stray loop devices..."

   local losetup_output
   losetup_output=$($SUDO_TO_ROOT losetup --all)

   if [ "$losetup_output" = "" ]; then
      true "INFO: Output of losetup_output is empty. No stray loop devices, OK."
      return 0
   fi

   error "Stray loop devices detected!

losetup_output: '$losetup_output'

This has been detected by the following command... To reproduce this manually, run...

sudo losetup --all ; echo $?

expected result:
0

In other words, this build script as currently implemented expects that there are no open loop devices.
'sudo losetup --all' should not have any output and exit with exit code 0.

If there is a legitimate loop device that should be ignored in this text, please report a bug.

Potential causes:
- A previously broken or aborted build might result in a stray loop device.

Recommendation:
- Reboot. Often a reboot is required to get rid of the stray loop device."

   true
}

check-stray-mounts() {
   true "INFO: Checking for mounts..."

   local proc_mounts_grep_result
   proc_mounts_grep_result=$($SUDO_TO_ROOT cat /proc/mounts | grep "$CHROOT_FOLDER") || true

   if [ "$proc_mounts_grep_result" = "" ]; then
      true "INFO: Output of proc_mounts_grep_result is empty. No stray mounts, OK."
      return 0
   fi

   error "Stray mounts detected!

proc_mounts_grep_result: '$proc_mounts_grep_result'

This has been detected by the following command... To reproduce this manually, run...

sudo cat /proc/mounts | grep '$CHROOT_FOLDER' ; echo $?

expected result:
1

Potential causes:
- A previously broken or aborted build might result in a stray mount.

Recommendation:
- Reboot. Often a reboot is required to get rid of the stray mount."

   true
}

check-copy-vms-into-raw() {
   if [ "$dist_build_internal_run" = "1" ]; then
      return 0
   fi

   if [ "$dist_build_type_long" = "kicksecure" ]; then
      true "INFO: kicksecure does not copy VM images into the build, ok."
      return 0
   fi

   if [ ! "$dist_build_iso" = "true" ]; then
      return 0
   fi

   local help_text
   help_text="A much later build step would try to copy these into the raw image and fail. Therefore we test it already here and fail early.

##########
If you want to do a debug build, perhaps create empty files?

qemu-img create -f qcow2 $copy_vms_into_raw_file_one 1M
qemu-img create -f qcow2 $copy_vms_into_raw_file_two 1M
##########
If you want to do a debug build, manually set which files you like to copy into the raw image using build configuration variables?

copy_vms_into_raw_file_one=$binary_build_folder_dist/Whonix-Gateway.qcow2 copy_vms_into_raw_file_two=$binary_build_folder_dist/Whonix-Workstation.qcow2
##########"

   if [ ! -f "$copy_vms_into_raw_file_one" ]; then
      error "Whonix VMs need to be build first before Whonix host can be build.

copy_vms_into_raw_file_one '$copy_vms_into_raw_file_one' does not exist!

$help_text"
   fi
   if [ ! -f "$copy_vms_into_raw_file_two" ]; then
      error "Whonix VMs need to be build first before Whonix host can be build

copy_vms_into_raw_file_two '$copy_vms_into_raw_file_two' does not exist!

$help_text"
   fi

   true
}

check-virtualbox-vm-exists() {
   if [ "$dist_build_internal_run" = "1" ]; then
      return 0
   fi
   if [ ! "$dist_build_virtualbox" = "true" ]; then
      return 0
   fi

   ## VirtualBox might not be installed at this point.
   ## Trying anyway, in case this script has already been run and installed
   ## VirtualBox beforehand.

   local command_v_exit_code="0"
   command -v VBoxManage >/dev/null || { command_v_exit_code="$?" ; true; }

   if [ ! "$command_v_exit_code" = "0" ]; then
      true "${cyan}INFO: VBoxManage command not yet available, ok.${reset}"
      return 0
   fi

   "$dist_source_help_steps_folder/vm-exists-test"

   true
}

check_required_packages_installed() {
   local required_packages_list required_package_item
   local required_packages_list="git time curl apt-cacher-ng lsb-release fakeroot fasttrack-archive-keyring"

   for required_package_item in $required_packages_list ; do
      if ! dpkg-query --show --showformat='${Version}' "$required_package_item" ; then
         error "${bold}${red}ERROR $BASH_SOURCE: Required package '$required_package_item' missing. Run:

sudo apt-get update

sudo apt-get install $required_packages_list${reset}"
      fi
   done

   true
}

signing_key() {
   true "INFO: GPG_AGENT_INFO: $GPG_AGENT_INFO"
   if [ "$dist_build_sign_local_repository" = "false" ]; then
      true "INFO: Skipping signing_key test because 'dist_build_sign_local_repository=false'."
   else
      if [ "$GPG_AGENT_INFO" = "" ]; then
         true "${cyan}${bold}INFO: Environment variable ${under}GPG_AGENT_INFO${eunder} is not set. gnupg-agent will not be available.${reset}"
      fi
      ## Letting a builder using a gpg key password cache its passwords early,
      ## so we do not pause the build process later when reprepro creates the
      ## local apt repository or when signing redistributable images.
      "$dist_source_help_steps_folder/gpg_test_sign"
   fi
}

main() {
   check-unicode "$@"
   check-source-folder-permissions "$@"
   check-stray-loop-devices "$@"
   check-stray-mounts "$@"
   check-copy-vms-into-raw "$@"
   check-virtualbox-vm-exists "$@"
   check_required_packages_installed "$@"
   signing_key "$@"

   source "$dist_source_help_steps_folder/git_sanity_test"

   git_sanity_test_main "$@"

   true
}

main "$@"
